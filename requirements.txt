
import os
import time
import json
import logging
from urllib.parse import urlparse
from datetime import timedelta
from flask import Flask, request, jsonify, session
from flask_cors import CORS
import requests
from requests.exceptions import HTTPError
import firebase_admin
from firebase_admin import credentials, firestore
from google.cloud.firestore_v1 import FieldFilter

# Setup logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
handler = logging.FileHandler('app.log')
handler.setLevel(logging.DEBUG)
logger.addHandler(handler)

# Initialize Firebase
firebase_json_str = os.environ.get("FIREBASE_CREDENTIALS")
db = None
if firebase_json_str and not firebase_admin._apps:
    try:
        cred_dict = json.loads(firebase_json_str)
        cred = credentials.Certificate(cred_dict)
        firebase_admin.initialize_app(cred)
        db = firestore.client()
        logger.info("âœ… Firebase initialized and Firestore client created")
    except Exception as e:
        logger.error(f"ðŸ”¥ Firebase initialization failed: {str(e)}")

app = Flask(__name__)

app.secret_key = os.environ.get('SECRET_KEY', os.urandom(24))
app.config.update(
    SESSION_COOKIE_NAME='createlo_session',
    SESSION_COOKIE_SECURE=True,
    SESSION_COOKIE_HTTPONLY=True,
    SESSION_COOKIE_SAMESITE='Lax',
    PERMANENT_SESSION_LIFETIME=timedelta(hours=1),
    SESSION_REFRESH_EACH_REQUEST=True
)

allowed_origins = [
    "https://audit.createlo.in",
    "http://localhost:3000",
    "http://localhost:3000/audit-form",
    "http://localhost:3000/business-summary"
]

CORS(app,
     supports_credentials=True,
     resources={
         r"/*": {
             "origins": allowed_origins,
             "methods": ["GET", "POST", "OPTIONS"],
             "allow_headers": ["Content-Type", "Authorization"],
             "expose_headers": ["Content-Type", "X-Error-Details"],
             "max_age": 600
         }
     })

GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')
logger.info(f"GEMINI_API_KEY: {'Set' if GEMINI_API_KEY else 'Not set'}")

@app.route('/')
def home():
    return jsonify({"status": "active", "service": "Createlo Audit API"})

@app.route('/submit', methods=['POST', 'OPTIONS'])
def submit():
    if request.method == 'OPTIONS':
        return _build_cors_preflight_response()
    
    try:
        if not request.is_json:
            logger.error("Request is not JSON")
            response = jsonify({"error": "Request must be JSON"})
            response.headers["X-Error-Details"] = "Invalid content type"
            response.status_code = 400
            return response
            
        data = request.get_json()
        logger.info(f"Received request with data: {json.dumps(data, indent=2)}")
        
        if not data:
            logger.error("No data received in request")
            response = jsonify({"error": "No data received"})
            response.headers["X-Error-Details"] = "Empty request body"
            response.status_code = 400
            return response

        # Validate required fields
        required_fields = ['website', 'email', 'contactNumber']
        missing_fields = [field for field in required_fields if not data.get(field)]
        if missing_fields:
            logger.error(f"Missing required fields: {missing_fields}")
            response = jsonify({
                "error": "Missing required fields",
                "missing": missing_fields
            })
            response.headers["X-Error-Details"] = f"Missing fields: {missing_fields}"
            response.status_code = 400
            return response

        # Validate email and phone
        if not validate_email(data.get('email', '')):
            logger.error(f"Invalid email format: {data.get('email', '')}")
            response = jsonify({"error": "Invalid email format"})
            response.headers["X-Error-Details"] = "Invalid email"
            response.status_code = 400
            return response
        if not validate_phone(data.get('contactNumber', '')):
            logger.error(f"Invalid phone number format: {data.get('contactNumber', '')}")
            response = jsonify({"error": "Invalid phone number format"})
            response.headers["X-Error-Details"] = "Invalid phone"
            response.status_code = 400
            return response

        business_url = data.get('website', '')
        if not is_valid_url(business_url):
            logger.error(f"Invalid business URL: {business_url}")
            response = jsonify({"error": "Invalid business URL"})
            response.headers["X-Error-Details"] = "Invalid URL"
            response.status_code = 400
            return response

        # Check cache in Firebase
        if db:
            try:
                cached = db.collection("audit_submissions").where(
                    filter=FieldFilter("inputData.website", "==", business_url)
                ).get()
                if cached:
                    cached_data = cached[0].to_dict()
                    logger.info("Returning cached audit report")
                    return _corsify_actual_response(jsonify({
                        "status": "success",
                        "data": cached_data["reportData"]
                    }))
            except Exception as e:
                logger.warning(f"Failed to check cache in Firebase: {str(e)}")

        # Build prompt and send to Gemini
        prompt = build_createlo_prompt(
            business_url,
            data.get('email', ''),
            data.get('contactNumber', ''),
            data.get('businessCategory', ''),
            data.get('categoryHint', ''),
            data.get('ownerName', ''),
            data.get('instagram', ''),
            data.get('facebook', '')
        )
        
        if not GEMINI_API_KEY:
            logger.error("Gemini API key not configured")
            response = jsonify({"error": "API service unavailable"})
            response.headers["X-Error-Details"] = "Missing API key"
            response.status_code = 503
            return response
            
        logger.info("Sending request to Gemini API")
        gemini_response = send_to_gemini(prompt)
        
        if isinstance(gemini_response, str) and "Too Many Requests" in gemini_response:
            logger.error("Gemini API rate limit exceeded")
            response = jsonify({
                "error": "Rate limit exceeded",
                "details": "Please try again later or contact Google Cloud Support for a higher quota."
            })
            response.headers["X-Error-Details"] = "API rate limit exceeded"
            response.status_code = 429
            return response
        elif isinstance(gemini_response, str) and "404 Client Error" in gemini_response:
            logger.error("Gemini API model not found")
            response = jsonify({
                "error": "Model not found",
                "details": "The requested Gemini model is unavailable."
            })
            response.headers["X-Error-Details"] = "Model not found"
            response.status_code = 502
            return response
        elif isinstance(gemini_response, str) and gemini_response.startswith("Error"):
            logger.error(f"Gemini API error: {gemini_response}")
            response = jsonify({"error": gemini_response})
            response.headers["X-Error-Details"] = "API error"
            response.status_code = 502
            return response

        report_data = extract_report_data(gemini_response)
        if not report_data:
            logger.error("Failed to extract report data from Gemini response")
            response = jsonify({
                "error": "Could not generate audit report",
                "details": "Failed to process API response"
            })
            response.headers["X-Error-Details"] = "Invalid API response"
            response.status_code = 500
            return response

        session['report_data'] = report_data
        logger.info("Successfully generated audit report")

        # Store in Firebase
        if db:
            try:
                combined_data = {
                    "inputData": data,
                    "reportData": report_data
                }
                db.collection("audit_submissions").add(combined_data)
                logger.info("Data successfully stored in Firebase")
            except Exception as firebase_error:
                logger.error(f"Failed to store data in Firebase: {str(firebase_error)}")

        return _corsify_actual_response(jsonify({
            "status": "success",
            "data": report_data
        }))

    except Exception as e:
        logger.error(f"Error in submit endpoint: {str(e)}", exc_info=True)
        response = jsonify({
            "error": "Internal server error",
            "details": str(e)
        })
        response.headers["X-Error-Details"] = "Unexpected error"
        response.status_code = 500
        return response

def is_valid_url(url):
    try:
        result = urlparse(url)
        return all([result.scheme in ['http', 'https'], result.netloc])
    except Exception as e:
        logger.error(f"Invalid URL {url}: {str(e)}")
        return False

def validate_email(email):
    pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
    return bool(re.match(pattern, email))

def validate_phone(phone):
    pattern = r'^\+?\d{10,15}$'
    return bool(re.match(pattern, phone))

def build_createlo_prompt(url, email, phone, category=None, category_hint=None, 
                         owner_name=None, instagram=None, facebook=None):
    additional_info = []
    if category:
        additional_info.append(f"Business Category: {category}")
    if category_hint:
        additional_info.append(f"Category Hint: {category_hint}")
    if owner_name:
        additional_info.append(f"Owner Name: {owner_name}")
    if instagram:
        additional_info.append(f"Instagram Handle: {instagram}")
    if facebook:
        additional_info.append(f"Facebook Page: {facebook}")
        
    additional_info_str = "\n".join(additional_info) + "\n" if additional_info else ""
    
    return f"""
You are a digital marketing audit expert working for the Createlo brand. Your goal is to analyze a business's website and provide insights and actionable next steps that highlight opportunities and encourage engagement with Createlo's services.
Business Data:
- URL: {url}
- Email: {email}
- Phone: {phone}
{additional_info_str}

Generate a detailed audit report with the following structure:

const reportData = {{
  // Basic business info inferred from website
  client: "<Business name>",
  businessoverview: "<1-2 sentence overview>",
  
  // Social media analysis (make reasonable assumptions if not provided)
  instagramSummary: "<analysis>",
  facebookSummary: "<analysis>",
  
  // Scores (60-100 range)
  instagramScore: <number>,
  facebookScore: <number>,
  overallScore: <average>,
  
  // Combined summary
  businesssummary: "<10-sentence summary>",
  
  // Marketing insights (4-8 items)
  insights: [
    "<specific insight>",
    "<specific insight>",
    "<specific insight>"
  ],
  
  // Generate several practical and actionable tips derived DIRECTLY from the generated 'insights'. Each tip should identify a specific area for improvement or opportunity related to their online presence (as inferred from the website) and suggest a relevant action. FRAME these tips to naturally lead into recommending a Createlo service (like booking a call, requesting an audit/quote, starting a test campaign) as the solution or next step. Maintain a professional, encouraging, yet action-oriented toneActionable tips (3-5 items)
  tips: [
    "<specific tip mentioning Createlo service>",
    "<specific tip mentioning Createlo service>",
    "<specific tip mentioning Createlo service>"
  ]
}};

IMPORTANT:

1. Maintain EXACT field order as shown above
2. Only return the JavaScript object
3. Scores should be between 60-100
4. Tips should reference Createlo services
5. Make reasonable assumptions for missing info
6. Ensure the response is valid JSON with no additional text, comments, or code blocks
"""

def send_to_gemini(prompt, retries=5, backoff_factor=3):
    models = ["gemini-1.5-pro-latest", "gemini-1.5-pro"]
    for model in models:
        try:
            url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={GEMINI_API_KEY}"
            headers = {'Content-Type': 'application/json'}
            
            payload = {
                "contents": [{
                    "parts": [{
                        "text": prompt
                    }]
                }],
                "safetySettings": [
                    {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_ONLY_HIGH"}
                ],
                "generationConfig": {
                    "temperature": 0.7,
                    "topP": 0.9,
                    "topK": 40,
                    "response_mime_type": "application/json"
                }
            }

            for attempt in range(retries):
                try:
                    logger.debug(f"Sending to Gemini API (model: {model})")
                    response = requests.post(url, headers=headers, json=payload, timeout=30)
                    logger.info(f"Response headers: {response.headers}")
                    response.raise_for_status()
                    
                    response_json = response.json()
                    logger.debug(f"API response: {json.dumps(response_json, indent=2)}")
                    
                    if not response_json.get('candidates'):
                        raise ValueError("No candidates in response")
                        
                    candidate = response_json['candidates'][0]
                    if 'content' not in candidate or 'parts' not in candidate['content']:
                        raise ValueError("Invalid response structure")
                        
                    parts = candidate['content']['parts']
                    if not parts or 'text' not in parts[0]:
                        raise ValueError("No text in response parts")
                        
                    return parts[0]['text']

                except (HTTPError, ValueError) as e:
                    if isinstance(e, HTTPError) and e.response.status_code == 429:
                        if attempt < retries - 1:
                            sleep_time = backoff_factor ** attempt
                            logger.warning(f"Rate limit hit for {model}, retrying in {sleep_time} seconds...")
                            time.sleep(sleep_time)
                            continue
                        else:
                            logger.error(f"Max retries reached for rate limit error with {model}")
                            if model == models[-1]:
                                return f"API Error: Too Many Requests after {retries} attempts"
                            break
                    else:
                        logger.error(f"API request failed for {model}: {str(e)}")
                        if model == models[-1]:
                            return f"API Error: {str(e)}"
                        break
                except Exception as e:
                    logger.error(f"Error processing response for {model}: {str(e)}")
                    if model == models[-1]:
                        return f"Processing Error: {str(e)}"
                    break

        except Exception as e:
            logger.error(f"Unexpected error: {str(e)}", exc_info=True)
            if model == models[-1]:
                return f"Processing Error: {str(e)}"

def extract_report_data(gemini_response):
    logger.debug(f"Raw Gemini response: {gemini_response}")
    try:
        # Try direct JSON parsing
        direct_parse = json.loads(gemini_response)
        if validate_report_data(direct_parse):
            return direct_parse
        
        # Extract JSON-like object with regex
        match = re.search(r'{[\s\S]*}', gemini_response, re.DOTALL)
        if match:
            js_object = match.group(0)
            logger.debug(f"Extracted JSON-like string: {js_object}")
            cleaned_data = clean_json_string(js_object)
            if cleaned_data and validate_report_data(cleaned_data):
                return cleaned_data
        
        logger.error("No valid JSON object found in response")
        return None

    except json.JSONDecodeError as e:
        logger.error(f"JSON decode error at position {e.pos}: {e.msg}")
        logger.error(f"Context: {gemini_response[max(0, e.pos-30):e.pos+30]}")
        return None
    except Exception as e:
        logger.error(f"Extraction error: {str(e)}", exc_info=True)
        return None

def clean_json_string(js_str):
    try:
        # Remove comments
        cleaned = re.sub(r'/\*.*?\*/', '', js_str, flags=re.DOTALL)
        cleaned = re.sub(r'//.*?$', '', cleaned, flags=re.MULTILINE)
        
        # Fix unquoted property names
        cleaned = re.sub(r'([{,]\s*)(\w+)\s*:', r'\1"\2":', cleaned)
        
        # Remove trailing commas
        cleaned = re.sub(r',\s*([}\]])', r'\1', cleaned)
        
        return json.loads(cleaned)
    except json.JSONDecodeError as e:
        logger.error(f"JSON cleaning failed: {str(e)}")
        return None

def validate_report_data(data):
    required_fields = {
        'client': str,
        'businessoverview': str,
        'instagramSummary': str,
        'facebookSummary': str,
        'instagramScore': (int, float),
        'facebookScore': (int, float),
        'overallScore': (int, float),
        'businesssummary': str,
        'insights': list,
        'tips': list
    }
    
    for field, field_type in required_fields.items():
        if field not in data:
            logger.error(f"Missing required field: {field}")
            return False
        
        if not isinstance(data[field], field_type):
            logger.error(f"Invalid type for {field}: expected {field_type}, got {type(data[field])}")
            return False
    
    for score_field in ['instagramScore', 'facebookScore', 'overallScore']:
        if not (60 <= data[score_field] <= 100):
            logger.error(f"Invalid {score_field}: must be between 60-100")
            return False
    
    for list_field in ['insights', 'tips']:
        if len(data[list_field]) < 2:
            logger.error(f"{list_field} must have at least 2 items")
            return False
    
    return True

def _build_cors_preflight_response():
    origin = request.headers.get('Origin')
    if origin not in allowed_origins:
        logger.error(f"Origin not allowed: {origin}")
        response = jsonify({"error": "Origin not allowed"})
        response.headers["X-Error-Details"] = "Invalid origin"
        response.status_code = 403
        return response
    response = jsonify({"message": "CORS preflight"})
    response.headers.add("Access-Control-Allow-Origin", origin)
    response.headers.add("Access-Control-Allow-Headers", "Content-Type, Authorization")
    response.headers.add("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
    response.headers.add("Access-Control-Allow-Credentials", "true")
    return response

def _corsify_actual_response(response):
    origin = request.headers.get('Origin')
    if origin in allowed_origins:
        response.headers.add("Access-Control-Allow-Origin", origin)
        response.headers.add("Access-Control-Allow-Credentials", "true")
        response.headers.add("Access-Control-Expose-Headers", "X-Error-Details")
    return response

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=os.environ.get('DEBUG', 'False') == 'True')
